GET /_cluster/health

GET /_nodes

GET /_cat/nodes?v

GET /_cat/shards?v

GET /_cat/indices?v&expand_wildcards=all

GET /_cat/indices?v


/* ------------------------------------- */

DELETE /pages

PUT /products
{
  "settings":{
    "number_of_shards" : 2,
    "number_of_replicas" : 2
  }
}

POST /products/_doc
{
  "name":"Coffee Maker",
  "price":64,
  "in_stock":10
}

PUT /products/_doc/100
{
  "name":"Toaster",
  "price":49,
  "in_stock":4
}

GET /products/_doc/100

//Updating existing key
POST /products/_update/100
{
  "doc":
  {
    "in_stock":3
  }
}

//Adding a new key for an existing document
POST /products/_update/100
{
  "doc":
  {
    "tags" : [
      "electronics"  
    ]
  }
}
//SCRIPTS
POST /products/_update/100
{
  "script":{
    "source" :"ctx._source.in_stock--"
  }
}

POST /products/_update/100
{
  "script":{
    "source" :"ctx._source.in_stock = 10"
  }
}

POST /products/_update/100
{
  "script":{
    "source" :"ctx._source.in_stock -= params.quantity",
    "params":{
      "quantity" : 4
    }
  }
}

POST /products/_update/100
{
  "script":{
    "source" : """
      if (ctx._source.in_stock == 0)
      {
        ctx.op = 'noop'
      }
      
      ctx._source.in_stock--;
    """
  }
}

POST /products/_update/100
{
  "script":{
    "source" : """
      if (ctx._source.in_stock > 0)
      {
        ctx._source.in_stock--;
      }
    """
  }
}

//UPSERT
POST /products/_update/101
{
  "script":{
    "source" :"ctx._source.in_stock++"
  },
  "upsert":{
    "name":"Blender",
    "price":399,
    "in_stock":5 
  }
}

POST /products/_update/101
{
  "upsert":{
    "name":"Blender",
    "price":399,
    "in_stock":5 
  },
  "script":{
    "source" :"ctx._source.in_stock++"
  }
}

GET /products/_doc/100

//REPLACING
PUT /products/_doc/100
{
  "name":"Toaster",
  "price":79,
  "in_stock":4
}

//DELETING
GET /products/_doc/101

DELETE /products/_doc/101

//VERSIONING
GET /products/_doc/100

POST /products/_update/100?if_primary_term=25&if_seq_no=32
{
  "doc":{
    "in_stock":123
  }
}

//UPDATE BY QUERY
POST /products/_update_by_query
{
  "script":{
    "source":"ctx._source.in_stock--"
  },
  "query":{
    "match_all": {
      
    }
  }
}

POST /products/_update_by_query
{
  "conflicts":"proceed",
  "script": {
    "source":"ctx._source.in_stock--"
  },
  "query":{
    "match_all": {
      
    }
  }
}

GET /products/_search
{
  "query":{
    "match_all": {}
  }
}

//DELETE BY QUERY
POST /products/delete_by_query
{
 "query":{
   "match_all": {}
 }
}

//BATCH PROCESSING
//Difference between index and create is, create fails if exists but index creates if not exists and updates if it exists

POST /_bulk
{ "index" : { "_index" : "products", "_id" : 195} }
{ "name" : "Espresso Machine", "price" : 199, "in_stock":5 }
{ "create" : { "_index" : "products", "_id":201 } }
{ "name" : "Milk 2", "price" : 145, "in_stock" : 14 }

POST /products/_bulk
{ "update" : { "_id" : 201 } }
{ "doc" : { "price" : 129 }}
{ "delete" : { "_id" : 200 } }


GET /products/_search 
{
  "query": {
    "match_all": {}
  }
}

GET /products/_doc/556 

GET /_cat/shards?v

//ANALYZER
POST /_analyze 
{
  "text" : "2 guys walk into a bar, but the third...",
  "analyzer" : "standard"
}

POST /_analyze 
{
  "text" : "2 guys walk into a bar, but the third..."
}

POST /_analyze 
{
  "text" : "2 guys walk into a bar, but the third...",
  "char_filter" : [],
  "tokenizer": "standard",
  "filter" : ["uppercase"]
}

//How the "keyword" analyzer works (Contains all the things in the text as a one thing (exact matching))
POST /_analyze
{
  "text":"2 guys walk into a bar, but the third...",
  "analyzer" : "keyword"
}

//COERCION TYPE
PUT /coercion_test/_doc/1
{
  "price" : 7.5
}

PUT /coercion_test/_doc/2
{
  "price" : "7.5"
}

PUT /coercion_test/_doc/3
{
  "price" : "7.5m"
}

GET /coercion_test/_doc/2

//------

//ARRAY
POST /_analyze
{
  "text" : ["Strings are simply", "merged together"],
  "analyzer" : "standard"
}

POST /_analyze
{
  "text" : [ 33, 44, 55 ],
  "analyzer" : "standard"
}

//MAPPING
PUT /reviews
{
  "mappings" : {
    "properties" : {
      "rating" : { "type" : "float" },
      "content" : { "type" : "text" },
      "product_id": { "type" : "integer" },
      "author" : {
        "properties":{
          "first_name":{ "type": "text" },
          "last_name": { "type" : "text" },
          "email": { "type" : "keyword" }
        }
      }
    }
  }
}

PUT /reviews/_doc/1 
{
  "rating" : 5.0,
  "content" : "Outstanding course ! Bo really taught me a lot about ElasticSearch",
  "product_id":123,
  "author": {
    "first_name":"John",
    "last_name":"Doe",
    "email":"johndoe123@example.com"
  }
}

GET /reviews/_search


//DATETIME format MAPPING
PUT my-index-002/_doc/1
{
  "time_is_up":"2023/02/03"
}

GET my-index-002/_mapping

PUT my-index-003
{
  "mappings" :{
    "dynamic_date_formats":["yyyy/MM", "MM/dd/yyyy"]
  }
}

GET my-index-003/_mapping

PUT my-index-003/_doc/1
{
  "create_date":"09/25/2024"
}

//NUMERIC DETECTION

PUT my-index-004
{
  "mappings":{
    "numeric_detection":true
  }
}

PUT my-index-004/_doc/1
{
  "my_float":"0.1",
  "my_integer":"1"
}

GET my-index-004/_mapping

GET my-index-004/_doc/1

//

PUT /students/_doc/1
{
  "name" : "Isaac Newton",  
  "age":  14, 
  "performance": "honor student"
}

GET /reviews/_mapping

GET /reviews/_mapping/field/content

GET /reviews/_mapping/field/author.email

//DOT NOTATION

PUT /reviews_dot_notation
{
  "mappings" : {
    "properties" : {
      "rating" : { "type" : "float" },
      "content" : { "type" : "text" },
      "product_id": { "type" : "integer" },
      "author.first_name" : { "type" : "text" },
      "author.last_name" : { "type" : "text" },
      "author.email" : { "type" : "keyword" }
    }
  }
}

GET /reviews_dot_notation/_mapping
GET /reviews/_mapping

//ADD EXISTING

PUT /reviews/_mapping 
{
  "properties": {
    "created_at" : {
      "type" : "date"
    }
  }
}

PUT /reviews/_mapping
{
  "properties" :{
    "product_id":{
      "type":"keyword"
    }
  }
}

GET /reviews/_search

PUT /reviews/_mapping
{
  "properties":{
    "author":{
      "properties":{
        "email":{
          "type" : "keyword"
        }
      }
    }
  }
}

// REINDEX DOCUMENTS

PUT /reviews_new
{
  "mappings": {
      "properties": {
        "author": {
          "properties": {
            "email": {
              "type": "keyword"
            },
            "first_name": {
              "type": "text"
            },
            "last_name": {
              "type": "text"
            }
          }
        },
        "content": {
          "type": "text"
        },
        "created_at": {
          "type": "date"
        },
        "product_id": {
          "type": "keyword"
        },
        "rating": {
          "type": "float"
        }
      }
    }
}

GET /reviews/_mappings

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  }
}

GET /reviews_new/_mappings
GET /reviews_new/_search
GET /reviews/_search

POST /reviews_new/_delete_by_query
{
  "query":{
    "match_all": {}
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  },
  "script": {
    "source": """
     if(ctx._source.product_id != null) {
       ctx._source.product_id = ctx._source.product_id.toString();
     }
    """
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews",
    "query": {
      "range": {
        "rating": {
          "gte": 2.0
        }
      }
    }
  },
  "dest": {
    "index": "reviews_new"
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews",
    "_source": ["content", "created_at", "rating"]
  },
  "dest": {
    "index": "reviews_new"
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  },
  "script": {
    "source": """
     // Rename "content" field to "comment"
     ctx._source.comment = ctx._source.remove("content");
    """
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  },
  "script": {
    "source": """
     if (ctx._source.rating < 4.0) {
       ctx.op = "noop"; // can also be set to "delete"
     }
    """
  }
}
//////////////////////////

GET /reviews/_search

GET /reviews/_mapping
PUT /reviews/_mapping
{
  "properties":{
    "comment":{
       "type" : "alias",
       "path" : "content"
    }
  }
}

GET /reviews/_search
{
  "query":{
    "match": {
      "comment": "outstanding"
    }
  }
}

PUT /multi_field_test
{
  "mappings":{
    "properties":{
      "description":{
        "type":"text"
      },
      "ingredients":{
        "type":"text",
        "fields":{
          "keyword":{
            "type":"keyword"
          }
        }
      }
    }
  }
}

POST /multi_field_test/_doc
{
  "description":"To make this carbonara, you first need to...",
  "ingredients" : ["Spaghetti", "Bacon", "Eggs"]
}


GET /multi_field_test/_search
{
  "query":{
    "match": {
      "ingredients": "spaghetti"
    }
  }
}

GET /multi_field_test/_search
{
  "query":{
    "term": {
      "ingredients.keyword": "Spaghetti"
    }
  }
}

PUT my-index-000001
{
  "mappings": {
    "properties": {
      "city": {
        "type": "text",
        "fields": {
          "raw": { 
            "type":  "keyword"
          }
        }
      }
    }
  }
}

GET /my-index-000001/_search
GET /my-index-000001

POST /my-index-000001/_doc
{
  "city":"Kocaeli"
}

GET my-index-000001/_search
{
  "query": {
    "match": {
      "city": "Istanbul" 
    }
  },
  "sort": {
    "city.raw": "asc" 
  },
  "aggs": {
    "Cities": {
      "terms": {
        "field": "city.raw" 
      }
    }
  }
}
//////

// INDEX TEMPLATES

PUT /_template/access-logs
{
  "index_patterns":["access-logs-*"],
  "settings": {
    "number_of_shards":2,
    "index.mapping.coerce":false
  },
  "mappings":{
    "properties":{
      "@timestamp":{
        "type":"date"
      },
      "url.original":{
        "type":"keyword"
      },
      "http.request.referrer":{
        "type":"keyword"
      },
      "http.response.status_code":{
        "type":"long"
      }
    }
  }
}

PUT /access-logs-2023-01-02

GET _template/access-logs

// Dymanic mapping

POST /my-index/_doc
{
  "tags" : ["computer","electronics"],
  "in_stock":4,
  "created_at":"2020/01/01 00:00:00"
}

GET /my-index/_mapping

////

// Combining explicit and dynamic mapping

POST /my-index/_doc
{
  "tags" : ["computer","electronics"],
  "in_stock":4,
  "created_at":"2020/01/01 00:00:00",
  "deneme" : "deneme"
}

GET /my-index/_search

///

// Configuring Dynamic Mapping

PUT /people
{
  "mappings":{
    "dynamic":false,
    "properties":{
      "first_name":{
        "type":"text"
      }
    }
  }
}

POST /people/_doc
{
  "first_name" : "Serhat",
  "age":27
}

GET /people/_mapping

GET /people/_search
{
  "query":{
    "match": {
      "first_name": "Serhat"
    }
  }
}

GET /people/_search
{
  "query":{
    "match": {
      "last_name": "Ayata"
    }
  }
}

DELETE /people

PUT /people
{
  "mappings":{
    "dynamic":"strict",
    "numeric_detection":true,
    "properties":{
      "first_name":{
        "type":"text"
      },
      "age":{
        "type":"float"
      }
    }
  }
}

// Dynamic Templates

PUT /dynamic_template_test
{
  "mappings":{
    "dynamic_templates":[
      {
        "integers":{
          "match_mapping_type":"long",
          "mapping":{
            "type":"integer"
          }
        }
      }
    ]
  }
}

POST /dynamic_template_test/_doc
{
  "in_stock":123
}

GET /dynamic_template_test/_mapping

PUT /test_index
{
  "mappings":{
    "dynamic_templates":[
      {
        "copy_to_full_name":{
          "match_mapping_type":"string",
          "path_match":"employer.name.*",
          "mapping": {
            "type":"text",
            "copy_to":"full_name"
          }
        }
      }
    ]
  }
}

POST /test_index/_doc
{
  "employer":{
    "name":{
      "first_name":"John",
      "middle_name":"Edward",
      "last_name":"Doe"
    }
  }
}

GET /test_index/_mapping

POST /test_index/_doc
{
  "employer":{
    "name":{
      "first_name":"Serhat",
      "middle_name":"test",
      "last_name":"Ayata"
    }
  }
}

GET /test_index/_search


PUT /test_index_2
{
  "mappings":{
    "dynamic_templates":[
      {
        "no_doc_value":{
          "match_mapping_type":"*",
          "mapping": {
            "type":"{dynamic_type}",
            "index":false
          }
        }
      }
    ]
  }
}


POST /test_index_2/_doc
{
  "name":"John Doe",
  "age":27
}

GET /test_index_2/_mapping

PUT /analyzer_test
{
  "settings":{
    "analysis":{
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "stop",
            "asciifolding"
          ]
        }
      }
    }
  }
}

PUT /analyzer_test2
{
  "settings":{
    "analysis":{
      "filter":{
        "danish_stop":{
          "type":"stop",
          "stopwords": "_danish_"
        }
      },
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "danish_stop",
            "asciifolding"
          ]
        }
      }
    }
  }
}

PUT /analyzer_test3
{
  "settings":{
    "analysis":{
      "filter":{
        "danish_stop":{
          "type":"stop",
          "stopwords": "_danish_"
        }
      },
      "char_filter" : {},
      "tokenizer" : {},
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "danish_stop",
            "asciifolding"
          ]
        }
      }
    }
  }
}

POST /_analyze
{
  "analyzer":"standard",
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

POST /_analyze
{
  "char_filter": ["html_strip"],
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

POST /analyzer_test/_analyze
{
  "analyzer":"my_custom_analyzer",
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

POST /analyzer_test2/_analyze
{
  "analyzer":"my_custom_analyzer",
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

// Adding and updating existing analyzer and see the changes of analyzer above
PUT /analyzer_test/_settings
{
  "analysis":{
      "analyzer":{
        "my_second_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "stop",
            "asciifolding"
          ]
        }
      }
  }
}

POST /analyzer_test/_close
POST /analyzer_test/_open

GET /analyzer_test/_settings

GET /analyzer_test/_mapping

PUT /analyzer_test/_mapping
{
  "properties":{
    "description":{
      "type":"text",
      "analyzer":"my_custom_analyzer"
    }
  }
}

POST /analyzer_test/_doc
{
  "description":"Is that what you need to do ?"
}

post /analyzer_test/_close
post /analyzer_test/_open

PUT /analyzer_test/_settings
{
  "settings":{
    "analysis":{
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "asciifolding"
          ]
        }
      }
    }
  }
}

GET /analyzer_test/_search
{
  "query":{
    "match":{
      "description": {
        "query": "that",
        "analyzer": "keyword"
      }
    }
  }
}

//reindexed, normally with analyzer_test, there was only one result but now two with this.
POST analyzer_test/_update_by_query?conflicts=proceed


PUT /test_map4
{
  "mappings": {
    "properties": {
      "title": { 
        "type": "text",
        "fields": {
          "en": { 
            "type":     "text",
            "analyzer": "english"
          },
          "fr": { 
            "type":     "text",
            "analyzer": "french"
          }
        }
      }
    }
  }
}

GET test_map4/_search
{
  "query": {
    "multi_match": {
      "query": "ce n'est pas",
      "fields": [ 
        "title",
        "title.en",
        "title.fr"
      ]
    }
  }
}

GET /test_map4/_mapping

GET /test_map4/_search

PUT /test_map4/_doc/2
{
  "title":"test_en ce n'est pas"
}


/// SEARCHES --------------------
GET /products/_mapping

GET /products/_search
{
  "query": {
    "match_all": {
      
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "name.keyword":"Wine - Maipo Valle Cabernet"
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "tags.keyword": "Vegetable"
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "is_active": true
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "tags.keyword": {
        "value": "2004/05/13"
      }
    }
  }
}

//Case insensitive term
GET /products/_search 
{
  "query": {
    "term": {
      "tags.keyword": {
        "value": "vegetable",
        "case_insensitive":true
      }
    }
  }
}

//tags.keyword CONTAINS "Soup" AND/OR "Meat" (Case sensitive)
//The terms query does not currently support the case insensitive query option
GET /products/_search 
{
  "query": {
    "terms": {
      "tags.keyword": [
        "Vegetable",
        "Soup"
      ]
    }
  }
}

//Retrieving Documents by IDs
GET /products/_search 
{
  "query": {
    "ids" : {
      "values" : [
        "100",  "200", "300"
      ]
    }
  }
}

//Range searches 
//Boundries included > <
GET /products/_search 
{
  "query": {
    "range": {
      "in_stock": {
        "gte": 1,
        "lte": 5
      }
    }
  }
}

//Boundries not included >= <=
GET /products/_search 
{
  "query": {
    "range": {
      "in_stock": {
        "gt": 1,
        "lt": 5
      }
    }
  }
}

//Data type is automatically understood
GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "gte": "2008/01/01",
        "lte": "2020/01/31"
      }
    }
  }
}

GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "gte": "2008/01/01 00:00:00",
        "lte": "2020/01/31 23:59:59"
      }
    }
  }
}

//query range with format
GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "format": "yyyy/MM/dd", 
        "gte": "2011/11/06",
        "lte": "2020/01/31"
      }
    }
  }
}

//query range with timezone
GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "format": "yyyy/MM/dd", 
        "time_zone": "+03:00", 
        "gte": "2011/11/06",
        "lte": "2020/01/31"
      }
    }
  }
}

//PREFIX - WILDCARDS - REGULAR EXPRESSIONS

//Prefix
GET /products/_search 
{
  "query": {
    "prefix": {
      "name.keyword": {
        "value": "Past"
      }
    }
  }
}

GET /products/_search 
{
  "query": {
    "prefix": {
      "tags.keyword": {
        "value": "Past"
      }
    }
  }
}

//Wildcard
GET /products/_search 
{
  "query": {
    "wildcard": {
      "tags.keyword": {
        "value": "Bee*"
      }
    }
  }
}

GET /products/_search 
{
  "query": {
    "wildcard": {
      "tags.keyword": {
        "value": "Bee?"
      }
    }
  }
}

//Regexp
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee(f|r)+"
      }
    }
  }
}
// After Bee, all letter between a-z and A-Z
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee[a-zA-Z]+"
      }
    }
  }
}

// 1 letter after Bee
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee(f|r){1}"
      }
    }
  }
}

//Get all starting with Bee
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee.*"
      }
    }
  }
}

//Get all ending with erage
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": ".*erage"
      }
    }
  }
}

//Get all including Beer
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": ".*Beer.*"
      }
    }
  }
}

//Case insensitive
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "beer.*",
        "case_insensitive" : true
      }
    }
  }
}


// -------------------------------------------

// Querying by field existence

GET /products/_search 
{
  "query": {
    "exists": {
      "field": "tags.keyword"
    }
  }
}

// If tags is an empty array, it will act like it doesn't exists
POST /products/_doc
{
  "name" : "Protein Powder",
  "tags" : ["Supplement"]
}

POST /products/_doc
{
  "name" : "Toast",
  "tags": [] // will act like this doesn't exists...
}

// Not existing

GET /products/_search 
{
  "query": {
    "bool": {
      "must_not": [
        {
          "exists": {
            "field": "tags.keyword"
          }
        }
      ]
    }
  }
}

// FULL TEXT QUERIES

GET /products/_search
{
  "query":{
    "match": {
      "body": "SHARDING"
    }
  }
}

// pasta and PASTA not differs because while indexing they are indexed as lowercase
// by the way, full text searches are analyzed, not like Term level queries
GET /products/_search
{
  "query":{
    "match": {
      "name" : "pasta"
    }
  }
}

GET /products/_search
{
  "query":{
    "match": {
      "name" : "PASTA"
    }
  }
}

// name contains multiple terms but it seperates them and 
// searches if the name has "pasta" OR "chicken"
// we can also use to decide whether we will use "OR" or "AND"
GET /products/_search
{
  "query":{
    "match": {
      "name" : "pasta chicken"
    }
  }
}

// Relevance scoring
GET /products/_search
{
  "sort" : [
    "_score"  
  ],
  "query":{
    "match": {
      "name" : {
        "query" :"pasta"
      }
    }
  }
}

// Searching Multiple Fields

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "vegetable",
      "fields": ["name","tags"]
    }
  }
}

// by using '^' , you can multiply the relevance score
GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "vegetable",
      "fields": ["name^2","tags"]
    }
  }
}

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","tags"],
      "tie_breaker": 0.3
    }
  }
}

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","tags"]
    }
  }
}

// Calculation
// "name" --> 12,69 score
// "tags" --> 5,56 score
// description --> N/A
// ingredients --> 4,55
// then 12,69 + 5,56*0.3 + 0 + 4,55*0.3

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","tags","description","ingredients"],
      "tie_breaker": 0.3
    }
  }
}

// by using *_ you can have a prefix for field, for example firstname-lastname --> *_name
GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","*_gs"],
      "tie_breaker": 0.3
    }
  }
}

// Types - best field
GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "best_fields",
      "fields":     [ "name", "description" ],
      "tie_breaker": 0.3
    }
  }
}

// This query will act like below
GET /products/_search
{
  "query" : {
    "dis_max": {
      "queries": [
        { "match": { "name": "pasta chicken" }},
        { "match": { "description": "pasta chicken" }}
      ],
      "tie_breaker": 0.3
    }
  }
}

//With operator "and", all terms must be present in a single field
GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "best_fields",
      "fields":     [ "name", "description" ],
      "operator": "and"
    }
  }
}
// With operator "or", one of the field must be present in a single field
GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "best_fields",
      "fields":     [ "name", "description" ],
      "operator": "or"
    }
  }
}

// Most fields

GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "most_fields",
      "fields":     [ "name", "description" ]
    }
  }
}

// Phrase and Phrase_prefix

GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta c",
      "type":       "phrase_prefix",
      "fields":     [ "name", "description" ]
    }
  }
}

// Phrase search

GET /products/_search
{
  "query":{
    "match": {
      "name": "Fanta Zero"
    }
  }
}

GET /products/_search
{
  "query":{
    "match": {
      "name": "Zero Fanta"
    }
  }
}

GET /products/_search
{
  "query":{
    "match": {
      "description": "Fanta Zero"
    }
  }
}

POST /_analyze
{
  "text":"Fresh egg pasta in a sauce made from tangy feta and dried chilli",
  "analyzer" : "standard"
}

GET /products/_search
{
  "query":{
    "match_phrase": {
      "description": "Fresh egg pasta"
    }
  }
}

// will be matched
GET /products/_search
{
  "query":{
    "match_phrase": {
      "description": "made from tangy"
    }
  }
}

// not matched because order isn't correct
GET /products/_search
{
  "query":{
    "match_phrase": {
      "description": "Fresh made from tangy"
    }
  }
}

// matched because "match" doesn't care about position, only cares whether it exists or not
GET /products/_search
{
  "query":{
    "match": {
      "description": "Fresh made from tangy"
    }
  }
}



























