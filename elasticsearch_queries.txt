GET /_cluster/health

GET /_nodes

GET /_cat/nodes?v

GET /_cat/shards?v

GET /_cat/indices?v&expand_wildcards=all

GET /_cat/indices?v


/* ------------------------------------- */

DELETE /pages

PUT /products
{
  "settings":{
    "number_of_shards" : 2,
    "number_of_replicas" : 2
  }
}

POST /products/_doc
{
  "name":"Coffee Maker",
  "price":64,
  "in_stock":10
}

PUT /products/_doc/100
{
  "name":"Toaster",
  "price":49,
  "in_stock":4
}

GET /products/_doc/100

//Updating existing key
POST /products/_update/100
{
  "doc":
  {
    "in_stock":3
  }
}

//Adding a new key for an existing document
POST /products/_update/100
{
  "doc":
  {
    "tags" : [
      "electronics"  
    ]
  }
}
//SCRIPTS
POST /products/_update/100
{
  "script":{
    "source" :"ctx._source.in_stock--"
  }
}

POST /products/_update/100
{
  "script":{
    "source" :"ctx._source.in_stock = 10"
  }
}

POST /products/_update/100
{
  "script":{
    "source" :"ctx._source.in_stock -= params.quantity",
    "params":{
      "quantity" : 4
    }
  }
}

POST /products/_update/100
{
  "script":{
    "source" : """
      if (ctx._source.in_stock == 0)
      {
        ctx.op = 'noop'
      }
      
      ctx._source.in_stock--;
    """
  }
}

POST /products/_update/100
{
  "script":{
    "source" : """
      if (ctx._source.in_stock > 0)
      {
        ctx._source.in_stock--;
      }
    """
  }
}

//UPSERT
POST /products/_update/101
{
  "script":{
    "source" :"ctx._source.in_stock++"
  },
  "upsert":{
    "name":"Blender",
    "price":399,
    "in_stock":5 
  }
}

POST /products/_update/101
{
  "upsert":{
    "name":"Blender",
    "price":399,
    "in_stock":5 
  },
  "script":{
    "source" :"ctx._source.in_stock++"
  }
}

GET /products/_doc/100

//REPLACING
PUT /products/_doc/100
{
  "name":"Toaster",
  "price":79,
  "in_stock":4
}

//DELETING
GET /products/_doc/101

DELETE /products/_doc/101

//VERSIONING
GET /products/_doc/100

POST /products/_update/100?if_primary_term=25&if_seq_no=32
{
  "doc":{
    "in_stock":123
  }
}

//UPDATE BY QUERY
POST /products/_update_by_query
{
  "script":{
    "source":"ctx._source.in_stock--"
  },
  "query":{
    "match_all": {
      
    }
  }
}

POST /products/_update_by_query
{
  "conflicts":"proceed",
  "script": {
    "source":"ctx._source.in_stock--"
  },
  "query":{
    "match_all": {
      
    }
  }
}

GET /products/_search
{
  "query":{
    "match_all": {}
  }
}

//DELETE BY QUERY
POST /products/delete_by_query
{
 "query":{
   "match_all": {}
 }
}

//BATCH PROCESSING
//Difference between index and create is, create fails if exists but index creates if not exists and updates if it exists

POST /_bulk
{ "index" : { "_index" : "products", "_id" : 195} }
{ "name" : "Espresso Machine", "price" : 199, "in_stock":5 }
{ "create" : { "_index" : "products", "_id":201 } }
{ "name" : "Milk 2", "price" : 145, "in_stock" : 14 }

POST /products/_bulk
{ "update" : { "_id" : 201 } }
{ "doc" : { "price" : 129 }}
{ "delete" : { "_id" : 200 } }


GET /products/_search 
{
  "query": {
    "match_all": {}
  }
}

GET /products/_doc/556 

GET /_cat/shards?v

//ANALYZER
POST /_analyze 
{
  "text" : "2 guys walk into a bar, but the third...",
  "analyzer" : "standard"
}

POST /_analyze 
{
  "text" : "2 guys walk into a bar, but the third..."
}

POST /_analyze 
{
  "text" : "2 guys walk into a bar, but the third...",
  "char_filter" : [],
  "tokenizer": "standard",
  "filter" : ["uppercase"]
}

//How the "keyword" analyzer works (Contains all the things in the text as a one thing (exact matching))
POST /_analyze
{
  "text":"2 guys walk into a bar, but the third...",
  "analyzer" : "keyword"
}

//COERCION TYPE
PUT /coercion_test/_doc/1
{
  "price" : 7.5
}

PUT /coercion_test/_doc/2
{
  "price" : "7.5"
}

PUT /coercion_test/_doc/3
{
  "price" : "7.5m"
}

GET /coercion_test/_doc/2

//------

//ARRAY
POST /_analyze
{
  "text" : ["Strings are simply", "merged together"],
  "analyzer" : "standard"
}

POST /_analyze
{
  "text" : [ 33, 44, 55 ],
  "analyzer" : "standard"
}

//MAPPING
PUT /reviews
{
  "mappings" : {
    "properties" : {
      "rating" : { "type" : "float" },
      "content" : { "type" : "text" },
      "product_id": { "type" : "integer" },
      "author" : {
        "properties":{
          "first_name":{ "type": "text" },
          "last_name": { "type" : "text" },
          "email": { "type" : "keyword" }
        }
      }
    }
  }
}

PUT /reviews/_doc/1 
{
  "rating" : 5.0,
  "content" : "Outstanding course ! Bo really taught me a lot about ElasticSearch",
  "product_id":123,
  "author": {
    "first_name":"John",
    "last_name":"Doe",
    "email":"johndoe123@example.com"
  }
}

GET /reviews/_search


//DATETIME format MAPPING
PUT my-index-002/_doc/1
{
  "time_is_up":"2023/02/03"
}

GET my-index-002/_mapping

PUT my-index-003
{
  "mappings" :{
    "dynamic_date_formats":["yyyy/MM", "MM/dd/yyyy"]
  }
}

GET my-index-003/_mapping

PUT my-index-003/_doc/1
{
  "create_date":"09/25/2024"
}

//NUMERIC DETECTION

PUT my-index-004
{
  "mappings":{
    "numeric_detection":true
  }
}

PUT my-index-004/_doc/1
{
  "my_float":"0.1",
  "my_integer":"1"
}

GET my-index-004/_mapping

GET my-index-004/_doc/1

//

PUT /students/_doc/1
{
  "name" : "Isaac Newton",  
  "age":  14, 
  "performance": "honor student"
}

GET /reviews/_mapping

GET /reviews/_mapping/field/content

GET /reviews/_mapping/field/author.email

//DOT NOTATION

PUT /reviews_dot_notation
{
  "mappings" : {
    "properties" : {
      "rating" : { "type" : "float" },
      "content" : { "type" : "text" },
      "product_id": { "type" : "integer" },
      "author.first_name" : { "type" : "text" },
      "author.last_name" : { "type" : "text" },
      "author.email" : { "type" : "keyword" }
    }
  }
}

GET /reviews_dot_notation/_mapping
GET /reviews/_mapping

//ADD EXISTING

PUT /reviews/_mapping 
{
  "properties": {
    "created_at" : {
      "type" : "date"
    }
  }
}

PUT /reviews/_mapping
{
  "properties" :{
    "product_id":{
      "type":"keyword"
    }
  }
}

GET /reviews/_search

PUT /reviews/_mapping
{
  "properties":{
    "author":{
      "properties":{
        "email":{
          "type" : "keyword"
        }
      }
    }
  }
}

// REINDEX DOCUMENTS

PUT /reviews_new
{
  "mappings": {
      "properties": {
        "author": {
          "properties": {
            "email": {
              "type": "keyword"
            },
            "first_name": {
              "type": "text"
            },
            "last_name": {
              "type": "text"
            }
          }
        },
        "content": {
          "type": "text"
        },
        "created_at": {
          "type": "date"
        },
        "product_id": {
          "type": "keyword"
        },
        "rating": {
          "type": "float"
        }
      }
    }
}

GET /reviews/_mappings

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  }
}

GET /reviews_new/_mappings
GET /reviews_new/_search
GET /reviews/_search

POST /reviews_new/_delete_by_query
{
  "query":{
    "match_all": {}
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  },
  "script": {
    "source": """
     if(ctx._source.product_id != null) {
       ctx._source.product_id = ctx._source.product_id.toString();
     }
    """
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews",
    "query": {
      "range": {
        "rating": {
          "gte": 2.0
        }
      }
    }
  },
  "dest": {
    "index": "reviews_new"
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews",
    "_source": ["content", "created_at", "rating"]
  },
  "dest": {
    "index": "reviews_new"
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  },
  "script": {
    "source": """
     // Rename "content" field to "comment"
     ctx._source.comment = ctx._source.remove("content");
    """
  }
}

POST /_reindex
{
  "source": {
    "index": "reviews"
  },
  "dest": {
    "index": "reviews_new"
  },
  "script": {
    "source": """
     if (ctx._source.rating < 4.0) {
       ctx.op = "noop"; // can also be set to "delete"
     }
    """
  }
}
//////////////////////////

GET /reviews/_search

GET /reviews/_mapping
PUT /reviews/_mapping
{
  "properties":{
    "comment":{
       "type" : "alias",
       "path" : "content"
    }
  }
}

GET /reviews/_search
{
  "query":{
    "match": {
      "comment": "outstanding"
    }
  }
}

PUT /multi_field_test
{
  "mappings":{
    "properties":{
      "description":{
        "type":"text"
      },
      "ingredients":{
        "type":"text",
        "fields":{
          "keyword":{
            "type":"keyword"
          }
        }
      }
    }
  }
}

POST /multi_field_test/_doc
{
  "description":"To make this carbonara, you first need to...",
  "ingredients" : ["Spaghetti", "Bacon", "Eggs"]
}


GET /multi_field_test/_search
{
  "query":{
    "match": {
      "ingredients": "spaghetti"
    }
  }
}

GET /multi_field_test/_search
{
  "query":{
    "term": {
      "ingredients.keyword": "Spaghetti"
    }
  }
}

PUT my-index-000001
{
  "mappings": {
    "properties": {
      "city": {
        "type": "text",
        "fields": {
          "raw": { 
            "type":  "keyword"
          }
        }
      }
    }
  }
}

GET /my-index-000001/_search
GET /my-index-000001

POST /my-index-000001/_doc
{
  "city":"Kocaeli"
}

GET my-index-000001/_search
{
  "query": {
    "match": {
      "city": "Istanbul" 
    }
  },
  "sort": {
    "city.raw": "asc" 
  },
  "aggs": {
    "Cities": {
      "terms": {
        "field": "city.raw" 
      }
    }
  }
}
//////

// INDEX TEMPLATES

PUT /_template/access-logs
{
  "index_patterns":["access-logs-*"],
  "settings": {
    "number_of_shards":2,
    "index.mapping.coerce":false
  },
  "mappings":{
    "properties":{
      "@timestamp":{
        "type":"date"
      },
      "url.original":{
        "type":"keyword"
      },
      "http.request.referrer":{
        "type":"keyword"
      },
      "http.response.status_code":{
        "type":"long"
      }
    }
  }
}

PUT /access-logs-2023-01-02

GET _template/access-logs

// Dymanic mapping

POST /my-index/_doc
{
  "tags" : ["computer","electronics"],
  "in_stock":4,
  "created_at":"2020/01/01 00:00:00"
}

GET /my-index/_mapping

////

// Combining explicit and dynamic mapping

POST /my-index/_doc
{
  "tags" : ["computer","electronics"],
  "in_stock":4,
  "created_at":"2020/01/01 00:00:00",
  "deneme" : "deneme"
}

GET /my-index/_search

///

// Configuring Dynamic Mapping

PUT /people
{
  "mappings":{
    "dynamic":false,
    "properties":{
      "first_name":{
        "type":"text"
      }
    }
  }
}

POST /people/_doc
{
  "first_name" : "Serhat",
  "age":27
}

GET /people/_mapping

GET /people/_search
{
  "query":{
    "match": {
      "first_name": "Serhat"
    }
  }
}

GET /people/_search
{
  "query":{
    "match": {
      "last_name": "Ayata"
    }
  }
}

DELETE /people

PUT /people
{
  "mappings":{
    "dynamic":"strict",
    "numeric_detection":true,
    "properties":{
      "first_name":{
        "type":"text"
      },
      "age":{
        "type":"float"
      }
    }
  }
}

// Dynamic Templates

PUT /dynamic_template_test
{
  "mappings":{
    "dynamic_templates":[
      {
        "integers":{
          "match_mapping_type":"long",
          "mapping":{
            "type":"integer"
          }
        }
      }
    ]
  }
}

POST /dynamic_template_test/_doc
{
  "in_stock":123
}

GET /dynamic_template_test/_mapping

PUT /test_index
{
  "mappings":{
    "dynamic_templates":[
      {
        "copy_to_full_name":{
          "match_mapping_type":"string",
          "path_match":"employer.name.*",
          "mapping": {
            "type":"text",
            "copy_to":"full_name"
          }
        }
      }
    ]
  }
}

POST /test_index/_doc
{
  "employer":{
    "name":{
      "first_name":"John",
      "middle_name":"Edward",
      "last_name":"Doe"
    }
  }
}

GET /test_index/_mapping

POST /test_index/_doc
{
  "employer":{
    "name":{
      "first_name":"Serhat",
      "middle_name":"test",
      "last_name":"Ayata"
    }
  }
}

GET /test_index/_search


PUT /test_index_2
{
  "mappings":{
    "dynamic_templates":[
      {
        "no_doc_value":{
          "match_mapping_type":"*",
          "mapping": {
            "type":"{dynamic_type}",
            "index":false
          }
        }
      }
    ]
  }
}


POST /test_index_2/_doc
{
  "name":"John Doe",
  "age":27
}

GET /test_index_2/_mapping

PUT /analyzer_test
{
  "settings":{
    "analysis":{
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "stop",
            "asciifolding"
          ]
        }
      }
    }
  }
}

PUT /analyzer_test2
{
  "settings":{
    "analysis":{
      "filter":{
        "danish_stop":{
          "type":"stop",
          "stopwords": "_danish_"
        }
      },
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "danish_stop",
            "asciifolding"
          ]
        }
      }
    }
  }
}

PUT /analyzer_test3
{
  "settings":{
    "analysis":{
      "filter":{
        "danish_stop":{
          "type":"stop",
          "stopwords": "_danish_"
        }
      },
      "char_filter" : {},
      "tokenizer" : {},
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "danish_stop",
            "asciifolding"
          ]
        }
      }
    }
  }
}

POST /_analyze
{
  "analyzer":"standard",
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

POST /_analyze
{
  "char_filter": ["html_strip"],
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

POST /analyzer_test/_analyze
{
  "analyzer":"my_custom_analyzer",
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

POST /analyzer_test2/_analyze
{
  "analyzer":"my_custom_analyzer",
  "text" : "I&apos;m in a <em>good<em> mood&nbsp;-&nbsp;and I <strong>love</strong> açai!"
}

// Adding and updating existing analyzer and see the changes of analyzer above
PUT /analyzer_test/_settings
{
  "analysis":{
      "analyzer":{
        "my_second_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "stop",
            "asciifolding"
          ]
        }
      }
  }
}

POST /analyzer_test/_close
POST /analyzer_test/_open

GET /analyzer_test/_settings

GET /analyzer_test/_mapping

PUT /analyzer_test/_mapping
{
  "properties":{
    "description":{
      "type":"text",
      "analyzer":"my_custom_analyzer"
    }
  }
}

POST /analyzer_test/_doc
{
  "description":"Is that what you need to do ?"
}

post /analyzer_test/_close
post /analyzer_test/_open

PUT /analyzer_test/_settings
{
  "settings":{
    "analysis":{
      "analyzer":{
        "my_custom_analyzer": {
          "type": "custom",
          "char_filter": ["html_strip"],
          "tokenizer": "standard",
          "filter":[
            "lowercase",
            "asciifolding"
          ]
        }
      }
    }
  }
}

GET /analyzer_test/_search
{
  "query":{
    "match":{
      "description": {
        "query": "that",
        "analyzer": "keyword"
      }
    }
  }
}

//reindexed, normally with analyzer_test, there was only one result but now two with this.
POST analyzer_test/_update_by_query?conflicts=proceed


PUT /test_map4
{
  "mappings": {
    "properties": {
      "title": { 
        "type": "text",
        "fields": {
          "en": { 
            "type":     "text",
            "analyzer": "english"
          },
          "fr": { 
            "type":     "text",
            "analyzer": "french"
          }
        }
      }
    }
  }
}

GET test_map4/_search
{
  "query": {
    "multi_match": {
      "query": "ce n'est pas",
      "fields": [ 
        "title",
        "title.en",
        "title.fr"
      ]
    }
  }
}

GET /test_map4/_mapping

GET /test_map4/_search

PUT /test_map4/_doc/2
{
  "title":"test_en ce n'est pas"
}


/// SEARCHES --------------------
GET /products/_mapping

GET /products/_search
{
  "query": {
    "match_all": {
      
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "name.keyword":"Wine - Maipo Valle Cabernet"
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "tags.keyword": "Vegetable"
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "is_active": true
    }
  }
}

GET /products/_search 
{
  "query": {
    "term": {
      "tags.keyword": {
        "value": "2004/05/13"
      }
    }
  }
}

//Case insensitive term
GET /products/_search 
{
  "query": {
    "term": {
      "tags.keyword": {
        "value": "vegetable",
        "case_insensitive":true
      }
    }
  }
}

//tags.keyword CONTAINS "Soup" AND/OR "Meat" (Case sensitive)
//The terms query does not currently support the case insensitive query option
GET /products/_search 
{
  "query": {
    "terms": {
      "tags.keyword": [
        "Vegetable",
        "Soup"
      ]
    }
  }
}

//Retrieving Documents by IDs
GET /products/_search 
{
  "query": {
    "ids" : {
      "values" : [
        "100",  "200", "300"
      ]
    }
  }
}

//Range searches 
//Boundries included > <
GET /products/_search 
{
  "query": {
    "range": {
      "in_stock": {
        "gte": 1,
        "lte": 5
      }
    }
  }
}

//Boundries not included >= <=
GET /products/_search 
{
  "query": {
    "range": {
      "in_stock": {
        "gt": 1,
        "lt": 5
      }
    }
  }
}

//Data type is automatically understood
GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "gte": "2008/01/01",
        "lte": "2020/01/31"
      }
    }
  }
}

GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "gte": "2008/01/01 00:00:00",
        "lte": "2020/01/31 23:59:59"
      }
    }
  }
}

//query range with format
GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "format": "yyyy/MM/dd", 
        "gte": "2011/11/06",
        "lte": "2020/01/31"
      }
    }
  }
}

//query range with timezone
GET /products/_search 
{
  "query": {
    "range": {
      "created": {
        "format": "yyyy/MM/dd", 
        "time_zone": "+03:00", 
        "gte": "2011/11/06",
        "lte": "2020/01/31"
      }
    }
  }
}

//PREFIX - WILDCARDS - REGULAR EXPRESSIONS

//Prefix
GET /products/_search 
{
  "query": {
    "prefix": {
      "name.keyword": {
        "value": "Past"
      }
    }
  }
}

GET /products/_search 
{
  "query": {
    "prefix": {
      "tags.keyword": {
        "value": "Past"
      }
    }
  }
}

//Wildcard
GET /products/_search 
{
  "query": {
    "wildcard": {
      "tags.keyword": {
        "value": "Bee*"
      }
    }
  }
}

GET /products/_search 
{
  "query": {
    "wildcard": {
      "tags.keyword": {
        "value": "Bee?"
      }
    }
  }
}

//Regexp
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee(f|r)+"
      }
    }
  }
}
// After Bee, all letter between a-z and A-Z
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee[a-zA-Z]+"
      }
    }
  }
}

// 1 letter after Bee
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee(f|r){1}"
      }
    }
  }
}

//Get all starting with Bee
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "Bee.*"
      }
    }
  }
}

//Get all ending with erage
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": ".*erage"
      }
    }
  }
}

//Get all including Beer
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": ".*Beer.*"
      }
    }
  }
}

//Case insensitive
GET /products/_search 
{
  "query": {
    "regexp": {
      "tags.keyword": {
        "value": "beer.*",
        "case_insensitive" : true
      }
    }
  }
}


// -------------------------------------------

// Querying by field existence

GET /products/_search 
{
  "query": {
    "exists": {
      "field": "tags.keyword"
    }
  }
}

// If tags is an empty array, it will act like it doesn't exists
POST /products/_doc
{
  "name" : "Protein Powder",
  "tags" : ["Supplement"]
}

POST /products/_doc
{
  "name" : "Toast",
  "tags": [] // will act like this doesn't exists...
}

// Not existing

GET /products/_search 
{
  "query": {
    "bool": {
      "must_not": [
        {
          "exists": {
            "field": "tags.keyword"
          }
        }
      ]
    }
  }
}

// FULL TEXT QUERIES

GET /products/_search
{
  "query":{
    "match": {
      "body": "SHARDING"
    }
  }
}

// pasta and PASTA not differs because while indexing they are indexed as lowercase
// by the way, full text searches are analyzed, not like Term level queries
GET /products/_search
{
  "query":{
    "match": {
      "name" : "pasta"
    }
  }
}

GET /products/_search
{
  "query":{
    "match": {
      "name" : "PASTA"
    }
  }
}

// name contains multiple terms but it seperates them and 
// searches if the name has "pasta" OR "chicken"
// we can also use to decide whether we will use "OR" or "AND"
GET /products/_search
{
  "query":{
    "match": {
      "name" : "pasta chicken"
    }
  }
}

// Relevance scoring
GET /products/_search
{
  "sort" : [
    "_score"  
  ],
  "query":{
    "match": {
      "name" : {
        "query" :"pasta"
      }
    }
  }
}

// Searching Multiple Fields

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "vegetable",
      "fields": ["name","tags"]
    }
  }
}

// by using '^' , you can multiply the relevance score
GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "vegetable",
      "fields": ["name^2","tags"]
    }
  }
}

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","tags"],
      "tie_breaker": 0.3
    }
  }
}

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","tags"]
    }
  }
}

// Calculation
// "name" --> 12,69 score
// "tags" --> 5,56 score
// description --> N/A
// ingredients --> 4,55
// then 12,69 + 5,56*0.3 + 0 + 4,55*0.3

GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","tags","description","ingredients"],
      "tie_breaker": 0.3
    }
  }
}

// by using *_ you can have a prefix for field, for example firstname-lastname --> *_name
GET /products/_search
{
  "query" : {
    "multi_match": {
      "query": "pasta chicken",
      "fields": ["name","*_gs"],
      "tie_breaker": 0.3
    }
  }
}

// Types - best field
GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "best_fields",
      "fields":     [ "name", "description" ],
      "tie_breaker": 0.3
    }
  }
}

// This query will act like below
GET /products/_search
{
  "query" : {
    "dis_max": {
      "queries": [
        { "match": { "name": "pasta chicken" }},
        { "match": { "description": "pasta chicken" }}
      ],
      "tie_breaker": 0.3
    }
  }
}

//With operator "and", all terms must be present in a single field
GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "best_fields",
      "fields":     [ "name", "description" ],
      "operator": "and"
    }
  }
}
// With operator "or", one of the field must be present in a single field
GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "best_fields",
      "fields":     [ "name", "description" ],
      "operator": "or"
    }
  }
}

// Most fields

GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta chicken",
      "type":       "most_fields",
      "fields":     [ "name", "description" ]
    }
  }
}

// Phrase and Phrase_prefix

GET /products/_search
{
  "query" : {
    "multi_match" : {
      "query":      "pasta c",
      "type":       "phrase_prefix",
      "fields":     [ "name", "description" ]
    }
  }
}

// Phrase search

GET /products/_search
{
  "query":{
    "match": {
      "name": "Fanta Zero"
    }
  }
}

GET /products/_search
{
  "query":{
    "match": {
      "name": "Zero Fanta"
    }
  }
}

GET /products/_search
{
  "query":{
    "match": {
      "description": "Fanta Zero"
    }
  }
}

POST /_analyze
{
  "text":"Fresh egg pasta in a sauce made from tangy feta and dried chilli",
  "analyzer" : "standard"
}

GET /products/_search
{
  "query":{
    "match_phrase": {
      "description": "Fresh egg pasta"
    }
  }
}

// will be matched
GET /products/_search
{
  "query":{
    "match_phrase": {
      "description": "made from tangy"
    }
  }
}

// not matched because order isn't correct
GET /products/_search
{
  "query":{
    "match_phrase": {
      "description": "Fresh made from tangy"
    }
  }
}

// matched because "match" doesn't care about position, only cares whether it exists or not
GET /products/_search
{
  "query":{
    "match": {
      "description": "Fresh made from tangy"
    }
  }
}

// Compound Queries

// Leaf Queries --> independent single query
// Compound query --> multiple queries for an algorithm

// 2 queries will be combined below

GET /products/_search
{
  "query":{
    "term": {
      "tags": {
        "value": "Alcohol"
      }
    }
  }
}

GET /products/_search
{
  "query":{
    "range": {
      "in_stock": {
        "lte": 5
      }
    }
  }
}

// BOOL QUERIES

//SQL QUERY :

// minimum_should_match : 1 --> at least one of them will match, if 2 then at least two of them will match

GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        { "term": {
            "tags.keyword": {
              "value": "Alcohol"
            }
          }
        }
      ],
      "must_not": [
        {
          "term": {
            "tags.keyword": {
              "value": "Wine"
            }
          }
        }
      ],
      "should": [
        {
          "term": {
            "tags.keyword": {
              "value": "Beer"
            }
          }
        },
        {
          "match": {
            "name": "beer"
          }
        },
        {
          "match": {
            "description": "beer"
          }
        }
      ],
      "minimum_should_match": 2
    }
  }
}

// Filter

// similar to must 
// ignores relevance scores (Better performance)

GET /products/_search
{
  "query":{
    "bool": {
      "filter": [
        {
          "term": {
            "tags.keyword": "Alcohol"
          }
        }
      ]
    }
  }
}

// Match and bool > must > term queries SAME

GET /products/_search
{
  "query":{
    "match": {
      "name": "PASTA ravioli"
    }
  }
}

//This term doesn't match
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "term": {
            "name": {
              "value": "pasta ravioli"
            }
          }
        }
      ]
    }
  }
}

GET /products/_search
{
  "query":{
    "match": {
      "name": "PASTA"
    }
  }
}

//This term matches
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "term": {
            "name": {
              "value": "pasta"
            }
          }
        }
      ]
    }
  }
}

// Match and bool > should > term queries SAME

GET /products/_search
{
  "query":{
    "match": {
      "name": "PASTA CHICKEN"
    }
  }
}

GET /products/_search
{
  "query":{
    "bool": {
      "should": [
        {
          "term": {
            "name": {
              "value": "pasta"
            }
          }
        },
        {
          "term": {
            "name": {
              "value": "chicken"
            }
          }
        }
      ]
    }
  }
}

// Match and bool > must > term with operator SAME

GET /products/_search
{
  "query":{
    "match": {
      "name": {
        "query": "PASTA CHICKEN",
        "operator": "and"
      }
    }
  }
}

GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "term": {
            "name": {
              "value": "pasta"
            }
          }
        },
        {
          "term": {
            "name": {
              "value": "chicken"
            }
          }
        }
      ]
    }
  }
}

// Select * From Products WHERE (tags IN ('Beer') OR name LIKE '%Beer%') AND in_stock <= 100

GET /products/_search
{
  "query":{
    "bool": {
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 100
            }
          }
        }
      ],
      "must": [
        {
          "bool": {
            "should": [
              {
                "term": {
                  "tags.keyword": {
                    "value": "Beer"
                  }
                }
              },
              {
                "term": {
                  "name": {
                    "value": "Beer"
                  }
                }
              }
            ]
          }
        }
      ]
    }
  }
}
// SAME AS ABOVE
GET /products/_search
{
  "query":{
    "bool": {
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 100
            }
          }
        }
      ],
      "should": [
        {
          "term": {
            "tags.keyword": {
              "value": "Beer"
            }
          }
        },
        {
          "term": {
            "name": {
              "value": "Beer"
            }
          }
        }
      ],
      "minimum_should_match": 1
    }
  }
}

// You can use it without Must > bool > should > term  by using minimum_should_match

// WHERE tags IN ('Beer') AND (name LIKE '%Beer%' OR description LIKE '%Beer%') AND in_stock <= 100

GET /products/_search
{
  "query":{
    "bool": {
      "should": [
        {
          "match": {
            "name": "Beer"
          }
        },
        {
          "match": {
            "description": "Beer"
          }
       }
      ],
      "minimum_should_match": 1, 
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 100
            }
          }
        },
        {
          "term": {
            "tags.keyword": {
              "value": "Beer"
            }
          } 
        }
      ]
    }
  }
}

// SAME AS ABOVE
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "bool": {
            "should": [
              {
                "match": {
                  "name": "Beer"
                }
              },
              {
                "match": {
                  "description": "Beer"
                }
              }
            ]
          }
        }
      ],
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 100
            }
          }
        },
        {
          "term": {
            "tags.keyword": {
              "value": "Beer"
            }
          } 
        }
      ]
    }
  }
}

// With a single query (SAME AS ABOVE)

GET /products/_search
{
  "query":{
    "bool": {
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 100
            }
          }
        },
        {
          "term": {
            "tags.keyword": {
              "value": "Beer"
            }
          } 
        }
      ],
      "must": [
        {
          "multi_match": {
            "query": "Beer",
            "fields": ["name","description"]
          }
        }
      ]
    }
  }
}

// BOOSTING QUERY

// The bool query enables us to increase relevance scores with should
// If we want to decrease relevance score :::

GET /products/_search
{
  "size" : 20,
  "query" : {
    "match": {
      "name": "JUICE"
    }
  }
}

// 0.5 with negative boost
GET /products/_search
{
  "size" : 20,
  "query" : {
    "boosting": {
      "positive": {
        "match": {
          "name": "juice"
        }
      },
      "negative": {
        "match": {
          "name": "apple"
        }
      },
      "negative_boost": 0.5
    }
  }
}

GET /products/_search
{
  "size" : 20,
  "query" : {
    "boosting": {
      "positive": {
        "match_all": {}
      },
      "negative": {
        "match": {
          "name": "apple"
        }
      },
      "negative_boost": 0.5
    }
  }
}

// Increasing relevance score of name containing 'pasta' by using should 
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "match_all": {}
        }
      ],
      "should": [
        {
          "term": {
            "name": {
              "value": "pasta"
            }
          }
        }
      ]
    }
  }
}

// Decreasing relevance score of name containing 'coffee' by using boosting

GET /products/_search
{
  "query":{
    "boosting": {
      "positive": {
        "match_all": {}
      },
      "negative": {
        "term": {
          "name": {
            "value": "coffee"
          }
        }
      },
      "negative_boost": 0.5
    }
  }
}

// Both 'pasta' and 'coffee'

// I like pasta, but not coffee

GET /products/_search
{
  "query":{
    "boosting": {
      "positive": {
        "term": {
          "name": {
            "value": "pasta"
          }
        }
      },
      "negative": {
        "term": {
          "name": {
            "value": "coffee"
          }
        }
      },
      "negative_boost": 0.5
    }
  }
}

// Boosting multiple queries, compound query

// I like pasta, but not coffee

GET /products/_search
{
  "query":{
    "boosting": {
      "positive": {
        "bool": {
          "must": [
            {
              "match_all": {}
            }
          ],
          "should": [
            {
              "term": {
                "name": {
                  "value": "pasta"
                }
              }
            }
          ]
        }
      },
      "negative": {
        "term": {
          "name": {
            "value": "coffee"
          }
        }
      },
      "negative_boost": 0.5
    }
  }
}

// SOME PRACTICES

// SQL: SELECT * FROM products  WHERE tags IN ("Alcohol")
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "term": {
            "tags.keyword": {
              "value": "Alcohol"
            }
          }
        }
      ]
    }
  }
}

//SQL: SELECT * FROM products WHERE tags IN ("Alcohol") AND tags NOT IN ("Wine")
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "term": {
            "tags.keyword": {
              "value": "Alcohol"
            }
          }
        }
      ],
      "must_not": [
        {
          "term": {
            "tags.keyword": {
              "value": "Wine"
            }
          }
        }
      ]
    }
  }
}

// SELECT * FROM products WHERE tags IN ('Beer') AND in_stock <= 20
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "term": {
            "tags.keyword": {
              "value": "Beer"
            }
          }
        }
      ],
      "must_not": [
        {
          "range": {
            "in_stock": {
              "lte": 20
            }
          }
        }
      ]
    }
  }
}

// SELECT * FROM products WHERE tags LIKE 'Bevera%' AND NOT LIKE 'Alco%'
GET /products/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "prefix": {
            "tags.keyword": {
              "value": "Bevera"
            }
          }
        }
      ],
      "must_not": [
        {
          "prefix": {
            "tags.keyword": {
              "value": "Alco"
            }
          }
        }
      ]
    }
  }
}

// SELECT * FROM products WHERE tags LIKE 'Bevera%' AND NOT LIKE 'Alco%'
GET /products/_search
{
  "query" : {
    "bool": {
      "must": [
        {
          "match": {
            "tags.keyword": "Wine"
          }
        }
      ],
      "should": [
        {
          "prefix": {
            "description.keyword": {
              "value": "Curabitur"
            }
          }
        }
      ],
      "minimum_should_match": 1
    }
  }
}

// If only should is used, then it will be like 'OR' if not it will be only used for boost
GET /products/_search
{
  "query":{
    "bool": {
      "should": [
        {
          "term": {
            "tags.keyword": {
              "value": "Beer"
            }
          }
        },
        {
          "match": {
            "name": "beer"
          }
        }
      ]
    }
  }
}

GET /products/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "prefix": {
            "name.keyword": {
              "value": "B"
            }
          }
        }
      ], 
      "should": [
        {
          "term": {
            "tags.keyword": "Beer"
          }
        },
        {
          "match": {
            "name": "beer"
          }
        }
      ],
      "minimum_should_match": 1
    }
  }
}

GET /products/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "tags.keyword": "Alcohol"
          }
        }
      ],
      "should": [
        {
          "prefix": {
            "name.keyword": {
              "value": "H"
            }
          }
        }
      ]
    }
  }
}

// SQL: SELECT * FROM products WHERE (tags IN ("Beer") OR name LIKE '%Beer%') AND in_stock <= 100
GET /products/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 60
            }
          }
        }
      ],
      "must": [
        {
          "bool": {
            "should": [
              { "term": { "tags.keyword": "Wine" } },
              { "match": { "name": "wine" } }
            ]
          }
        }
      ]
    }
  }
}

GET /products/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 100
            }
          }
        }
      ],
      "should": [
        { "term": { "tags.keyword": "Wine" } },
        { "match": { "name": "wine" } }
      ],
      "minimum_should_match": 1
    }
  }
}

// SQL: SELECT * FROM products WHERE tags IN ("Beverage") AND (name LIKE '%Wi%' OR description LIKE '%Wine%') AND in_stock <= 70
GET /products/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 70
            }
          }
        },
        {
          "term": {
            "tags.keyword": "Beverage"
          }
        }
      ],
      "should": [
        { "match": { "name": "Wine" } },
        { "match": { "description": "Wine" } }
      ],
      "minimum_should_match": 1
    }
  }
}

GET /products/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "range": {
            "in_stock": {
              "lte": 70
            }
          }
        },
        {
          "term": {
            "tags.keyword": "Beverage"
          }
        }
      ],
      "must": [
        {
          "multi_match": {
            "query": "Wine",
            "fields": ["name", "description"]
          }
        }
      ]
    }
  }
}

// Disjunction max (dis_max)
// This is like multimatch queries

//Highest score is 6.059989
GET /products/_search 
{
  "query":{
    "dis_max": {
      "queries": [
        { "match": { "name": "Beer" } },
        { "match": { "tags": "Beer" } }
      ]
    }
  }
}

// When we use tie_breaker , highest score is stabil and other will be multiplied with tie breaker
// then multiplied value will be added to highest score...
// Highest score is 6.975373
GET /products/_search
{
  "query":{
    "dis_max": {
      "queries": [
        { "match": { "name": "Beer" } },
        { "match": { "tags": "Beer" } }
      ],
      "tie_breaker": 0.3
    }
  }
}

//Check the difference about highest scores... it is differs from disjunction
GET /products/_search
{
  "query":{
    "multi_match": {
      "query": "beer",
      "fields": [
        "description", "name"
      ],
      "tie_breaker": 0.3
    }
  }
}

// NESTED OBJECTS 

GET /recipes/_search

// Nested Objects are indexed as a group like;
//{
//  "ingredients" : [
//    {
//      "name" : "Freshly grated Parmesan cheese",
//      "amount" : 55,
//      "unit" : "grams"
//    },
//    {
//      "name" : "Freshly ground black pepper"
//    },
//    {
//      "name" : "Mixed mushrooms",
//      "amount":225,
//      "unit":"grams"
//    },
//    {
//      "name":"Dried orecchiette",
//      "amount":450,
//      "unit":"grams"
//    },
//    {
//      "name":"Cloves garlic",
//      "amount":2,
//      "unit":"pcs"
//    }
//  ]
//}

// these ingredients above are indexed like this

//{
//  "ingredients.name":[
//    "Freshly grated Parmesan cheese",
//    "Freshly ground black pepper",
//    "Mixed mushrooms",
//    "Dried orecchiette",
//    "Cloves garlic"
//  ],
//  "ingredients.amount":[55,225,450,2],
//  "ingredients.unit":[
//    "grams", "grams", "grams", "pcs"
//  ]
//}

// so, when we search for ingredients.name = parmesan and range greater or equal than 100 
// it will give us different results from expected because it searches parmesan in all values indexed above
// after searching, it will find Parmesan in ingredients.name's all values
// and then searches for ingredients.amount and then it "greater or equal to 100" will be found in [55,225,450,2]

// This asks 
// if our ingredients have "parmesan" and 
// if we have an ingredient amount greater or equal than 100
GET /recipes/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "match": {
            "ingredients.name": "parmesan"
          }
        },
        {
          "range": {
            "ingredients.amount": {
              "gte": 100
            }
          }
        }
      ]
    }
  }
}

// in order to get rid of this "UNPREDICTABLE" situation, we should use nested data type

GET /recipes/_mapping


//REINDEXED and added data again
PUT /recipes
{
  "mappings" : {
    "properties":{
      "title" : { "type" : "text" },
      "description" : { "type" : "text" },
      "preparation_time_minutes" : { "type" : "integer" },
      "steps" : { "type" : "text" },
      "created" : { "type" : "date" },
      "ratings" : { "type" : "float" },
      "servings" : {
        "properties" : {
          "min" : { "type" : "integer" },
          "max" : { "type" : "integer" }
        }
      },
      "ingredients": {
        "type" : "nested",
        "properties" : {
          "name" : {
            "type" : "text",
            "fields" : {
              "keyword" : {
                "type" : "keyword"
              }
            }
          },
          "amount" : { "type" : "integer" },
          "unit" : { "type" : "keyword" }
        }
      }
    }
  }
}

// This doesn't work, we should use nested queries
GET /recipes/_search
{
  "query" : {
    "bool" : {
      "must": [
        {
          "match": {
            "ingredients.name": "parmesan"
          }
        },
        {
          "range": {
            "ingredients.amount": {
              "gte": 100
            }
          }
        }
      ]
    }
  }
}

// We are searhing for an ingredient including match of "parmesan" AND less than 100 amount together
GET /recipes/_search
{
  "query" : {
    "nested" : {
      "path": "ingredients",
      "query": {
        "bool" : {
          "must": [
            {
              "match": {
                "ingredients.name": "parmesan"
              }
            },
            {
              "range": {
                "ingredients.amount": {
                  "lte": 100
                }
              }
            }
          ]
        }
      }
    }
  }
}

// Matching child objects of nested affect the parent document's relevance score
// Each matching child oject will be calculated for relevance score
// Relevance scoring can be configured with "score_mode"
// avg (default) : The average relevance score of matching child objects
// min : the minimum relevance score of matching child objects
// max : the maximum relevance score of matching child objects
// sum : The sum of all matching child objects' relevance scores
// none : ignore relevance scores for matching child object


// NESTED INNER HITS

GET /recipes/_search
{
  "query" : {
    "nested" : {
      "path": "ingredients",
      "inner_hits": {}, 
      "query": {
        "bool" : {
          "must": [
            {
              "match": {
                "ingredients.name": "parmesan"
              }
            },
            {
              "range": {
                "ingredients.amount": {
                  "lte": 100
                }
              }
            }
          ]
        }
      }
    }
  }
}

// Normally results would be like this
//{
//  "took": 16,
//  "timed_out": false,
//  "_shards": {
//    "total": 1,
//    "successful": 1,
//    "skipped": 0,
//    "failed": 0
//  },
//  "hits": {
//      "total": {
//      "value": 3,
//      "relation": "eq"
//    },
//    "max_score" : 4.4121,
//    "hits" : [
//      
//    ]
//  }
//}

// And hits of the data result above like this

//{
//  "_index": "recipes",
//  "type":"_doc",
//  "_id": "10",
//  "_score": 3.9802299,
//  "_source": {
//    
//  }
//}

// Inner hits like this
// "offset" is the index of the ingredients 

//"inner_hits": {
//  "ingredients": {
//    "hits": {
//      "total": {
//        "value": 1,
//        "relation": "eq"
//      },
//      "max_score": 3.9802299,
//      "hits": [
//        {
//          "_index": "recipes",
//          "_id": "10",
//          "_nested": {
//            "field": "ingredients",
//            "offset": 6
//          },
//          "_score": 3.9802299,
//          "_source": {
//            "name": "Finely grated Parmesan cheese",
//            "amount": 60,
//            "unit": "grams"
//          }
//        }
//      ]
//    }
//  }
//}

// We can change inner hits parameters
// inner_hits.name --> changed the title of "hits" of inner hits
// inner_hits.size --> how many hits we will get as a result (First 10 hits) (Default : 3 hits)
GET /recipes/_search
{
  "query" : {
    "nested" : {
      "path": "ingredients",
      "inner_hits": {
        "name": "my_hits",
        "size":10
      }, 
      "query": {
        "bool" : {
          "must": [
            {
              "match": {
                "ingredients.name": "parmesan"
              }
            },
            {
              "range": {
                "ingredients.amount": {
                  "lte": 100
                }
              }
            }
          ]
        }
      }
    }
  }
}

// NESTED FILEDS LIMITATIONS

// Default 50 MAX Nested fields per index
// Can be changed "index.mapping.nested_fields.limit" (not recommended)
// As default, 10.000 nested objects per document, can be changed "index.mapping.nested_objects.limit" (not recommended)

// If we keep orders as a nested field, doesn't make sense,
// Nested field orders and its nested field lines
// The number of objects between the two fields will contains the 10.000 objects limit
// And that would be really easy to reach 10.000 orders for a shop,
// This is not a good design

//{
//  "store_id" : "ob78s35qd",
//  "name" : "Pizza Shack",
//  "website":"https://pizza-shack.com",
//  "orders" :[
//    {
//      "order_id" : "order-6821",
//      "customer" : "Srht",
//      "ordered_at" : "2023-03-02T11:56:23Z",
//      "comment" : "can be good",
//      "lines" : [
//        {
//          "product":"Veggie Deluxe",
//          "quantity" : 2
//        },
//        {
//          "product":"Meat Lover",
//          "quantity" : 2
//        }
//        ...
//      ]
//    }
//  ]
//}

// We should split to 2 indices, so 10.000 rule cannot be reached for an order 
// because it will be only available for "lines" not for "orders"
// When the order is completed, no line will be added to it so we cannot reach the limit

// STORE

//{
//  "store_id" : "ob78s35qd",
//  "name" : "Pizza Shack",
//  "website":"https://pizza-shack.com"
//  ...
//}

// ORDER

//{
//  "order_id" : "order-6821",
//  "store_id" : "ob78s35qd",
//  "customer" : "Srht",
//  "ordered_at" : "2023-03-02T11:56:23Z",
//  "comment" : "can be good",
//  "lines" : [
//    {
//      "product":"Veggie Deluxe",
//      "quantity" : 2
//    },
//    {
//      "product":"Meat Lover",
//      "quantity" : 2
//    }
//    ...
//  ]
//}

// JOINING QUERIES

// Mapping document relationships

PUT /department
{
  "mappings": {  
    "properties": {
      "join_field":{
        "type":"join",
        "relations" : {
          "department" : "employee"
        }
      }
    }
  }
}

PUT /department/_doc/1
{
  "name" : "Development",
  "join_field": "department"
}
// SAME
PUT /department/_doc/2
{
  "name" : "Marketing",
  "join_field": "department"
}

//routing -> ParentId
PUT /department/_doc/3?routing=1
{
  "name" : "Srht",
  "age" : 28,
  "gender" : "M",
  "join_field": {
    "name" : "employee",
    "parent" : 1
  }
}

PUT /department/_doc/4?routing=2
{
  "name" : "Mrt",
  "age" : 22,
  "gender" : "M",
  "join_field": {
    "name" : "employee",
    "parent" : 2
  }
}

PUT /department/_doc/5?routing=1
{
  "name" : "Snna",
  "age" : 33,
  "gender" : "F",
  "join_field": {
    "name" : "employee",
    "parent" : 1
  }
}

PUT /department/_doc/6?routing=2
{
  "name" : "Edn",
  "age" : 43,
  "gender" : "F",
  "join_field": {
    "name" : "employee",
    "parent" : 2
  }
}


GET /department/_search
{
  "query" : {
    "parent_id" : {
      "type" : "employee",
      "id" : 1
    }
  }
}

GET /department/_search
{
  "query" : {
    "parent_id" : {
      "type" : "employee",
      "id" : 2
    }
  }
}

// Querying child documents by parent
// To enable the score of child elements, we should set "score" for it.
GET /department/_search
{
  "query" : {
    "has_parent": {
      "parent_type": "department",
      "score" : true,
      "query": {
        "term": {
          "name.keyword": {
            "value": "Development"
          }
        }
      }
    }
  }
}

// Querying parent by child documents
// SELECT d.Name, d.join_field FROM employee e INNER JOIN department d ON d.join_field = e.join_field.name WHERE e.age > 40 
// Boosting with gender "M"
GET /department/_search
{
  "query" : {
    "has_child": {
      "type": "employee",
      "query": {
        "bool": {
          "must": [
            {
              "range": {
                "age": {
                  "gte": 40
                  }
              }
            }
          ],
          "should": [
            {
              "term": {
                "gender.keyword": {
                  "value": "M"
                }
              }
            }
          ]
        }
      }
    }
  }
}

// Score modes
// min -> lowest score of matching child documents is mapped into the parent
// max -> highest score of matching child documents is mapped into the parent
// sum -> matching children's scores are summed up and mapped into the parent
// avg -> the average score based on matching child documents is mapped into the parent
// none -> scores of child documents are ignored. Default value

// min_children -> Children count must be higher than this.
// max_children -> Children count must be lower than this.

GET /department/_search
{
  "query" : {
    "has_child": {
      "type": "employee",
      "score_mode": "sum", 
      "min_children": 2, 
      "max_children": 5, 
      "query": {
        "bool": {
          "must": [
            {
              "range": {
                "age": {
                  "gte": 20
                  }
              }
            }
          ]
        }
      }
    }
  }
}

// We have been working on one level of relations so far,

// Multi Level Relations

//                       Company
//            Department  ---   Supplier
//    Employee

PUT /company
{
  "mappings": {
    "properties": {
      "join_field": {
        "type": "join",
        "relations": {
          "company": [
            "department",
            "supplier"
          ],
          "department": "employee"
        }
      }
    }
  }
}

// As a routing, we have to specify the master of all, so it has to be 1
// It was the same rules as one level relation, bu we didn't notice that because there was only one level for it.
//First, add a company

PUT /company/_doc/1
{
  "name" : "My Company Inc.",
  "join_field" : "company"
}

// Add a department to this company

PUT /company/_doc/2?routing=1
{
  "name" : "Development",
  "join_field" : {
    "name" : "department",
    "parent" : 1
  }
}

// Add an employee to this department

PUT /company/_doc/3?routing=1
{
  "name" : "Serhat A",
  "join_field" : {
    "name" : "employee",
    "parent" : 2
  }
}

//
PUT /company/_doc/4
{
  "name" : "Another Company Inc.",
  "join_field" : "company"
}

PUT /company/_doc/5?routing=4
{
  "name" : "Marketing",
  "join_field" : {
    "name" : "department",
    "parent" : 4
  }
}

PUT /company/_doc/6?routing=4
{
  "name" : "Serhat B",
  "join_field" : {
    "name" : "employee",
    "parent" : 5
  }
}
// Searching multi level relations

// QUERY : Search for a company which contains at least one department that has an employee named 'Serhat B'

GET /company/_search
{
  "query" : {
    "has_child": {
      "type": "department",
      "query": {
        "has_child": {
          "type": "employee",
          "query": {
            "term": {
              "name.keyword": {
                "value": "Serhat A"
              }
            }
          }
        }
      }
    }
  }
}

// PARENT - CHILD Inner Hits

// First, look for Department, get parents by child
GET /department/_search
{
  "query" : {
    "has_child": {
      "type": "employee",
      "inner_hits": {}, 
      "query": {
         "bool": {
           "must": [
             {
               "range": {
                 "age": {
                   "gte": 40
                 }
               }
             }
           ],
           "should": [
             {
               "term": {
                 "gender.keyword": {
                   "value": "M"
                 }
               }
             }
           ]
         }
      }
    }
  }
}

// Get childs by parent

GET /department/_search
{
  "query" : {
    "has_parent": {
      "parent_type": "department",
      "inner_hits" : {},
      "query": {
        "term": {
          "name.keyword": {
            "value": "Development"
          }
        }
      }
    }
  }
}


// TERMS LOOKUP MECHANISM

PUT /users/_doc/1
{
  "name" : "John Roberts",
  "following" : [2,3]
}

PUT /users/_doc/2
{
  "name" : "Eliz Ross",
  "following" : []
}

PUT /users/_doc/3
{
  "name" : "Jeremy Brooks",
  "following" : [1,2]
}

PUT /users/_doc/4
{
  "name" : "Diana Moore",
  "following" : [3,1]
}

PUT /stories/_doc/1
{
  "user" : 3,
  "content" : "Wow look, a penguin"
}

PUT /stories/_doc/2
{
  "user" : 1,
  "content" : "Just another day"
}

PUT /stories/_doc/3
{
  "user" : 1,
  "content" : "Making search..."
}

PUT /stories/_doc/4
{
  "user" : 4,
  "content" : "Great day"
}

PUT /stories/_doc/5
{
  "user" : 4,
  "content" : "Yes, totally"
}

PUT /stories/_doc/6
{
  "user" : 2,
  "content" : "It's chilly !"
}


// Explanation
// First, it searches for Id : 1 user in users
// When it finds the user then following would be [2,3]
// Then it creates a new query inside like below

// GET /stories/_search
//{
//  "query" : {
//    "terms" : {
//       "user" : [2,3]
//    {  
//  {   
//}

GET /stories/_search
{
   "query" : {
     "terms" : {
       "user" : {
          "index" : "users",
          "id" : "1",
          "path" : "following"
       }
     }
  }
}

